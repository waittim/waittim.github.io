I"x <p>In the process of completing the mask detection project recently, I tried to convert Darknet into a Keras model. In other words, to convert the <code class="highlighter-rouge">.cfg</code> file and the <code class="highlighter-rouge">.weights</code> file into a <code class="highlighter-rouge">.h5</code> file.</p>

<p>There are actually some ready-made codes online to complete this process, such as <a href="https://github.com/allanzelener/YAD2K">YAD2K</a> and <a href="https://github.com/qqwweee/keras-yolo3">keras-yolo3</a>. However, the most recent update of these repository was at least three years ago. The Keras used is an older version. The new version of Keras has been embedded in TensorFlow 2.0.</p>

<p>Secondly, during the converting, I met a issue called <code class="highlighter-rouge">buffer is too small for requested array</code>. After check the transformation process, I found it cannot handle group convolutional layers.</p>

<p>Therefore, after referring to the relevant information on the Internet, I modified the <code class="highlighter-rouge">convert.py</code> to be based on TensorFlow 2.0 and able to deal with group in convolutional layers.</p>

<p>Regarding the modification of the grouped convolutional layer, the main part of the code is as follows:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="n">groups</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">block</span><span class="p">[</span><span class="s">'groups'</span><span class="p">])</span> <span class="k">if</span> <span class="s">'groups'</span> <span class="ow">in</span> <span class="n">block</span> <span class="k">else</span> <span class="mi">1</span>
        <span class="c1"># Other content...
</span>
        <span class="n">weights_shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">prev_layer_shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="n">groups</span><span class="p">),</span> <span class="n">filters</span><span class="p">)</span>
        <span class="c1"># Other content...
</span>        
        <span class="n">conv_layer</span> <span class="o">=</span> <span class="p">(</span><span class="n">Conv2D</span><span class="p">(</span>
                <span class="n">filters</span><span class="p">,</span> <span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">size</span><span class="p">),</span>
                <span class="n">strides</span><span class="o">=</span><span class="p">(</span><span class="n">stride</span><span class="p">,</span> <span class="n">stride</span><span class="p">),</span>
                <span class="n">kernel_regularizer</span><span class="o">=</span><span class="n">l2</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">weight_decay</span><span class="p">),</span>
                <span class="n">use_bias</span><span class="o">=</span><span class="ow">not</span> <span class="n">batch_normalize</span><span class="p">,</span>
                <span class="n">weights</span><span class="o">=</span><span class="n">conv_weights</span><span class="p">,</span>
                <span class="n">activation</span><span class="o">=</span><span class="n">act_fn</span><span class="p">,</span>
                <span class="n">groups</span><span class="o">=</span><span class="n">groups</span><span class="p">,</span>
                <span class="n">padding</span><span class="o">=</span><span class="n">padding</span><span class="p">))(</span><span class="bp">self</span><span class="o">.</span><span class="n">prev_layer</span><span class="p">)</span>

</code></pre></div></div>

<p>The entire code of the <code class="highlighter-rouge">convert.py</code> is as follows:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">io</span>
<span class="kn">import</span> <span class="nn">argparse</span>
<span class="kn">import</span> <span class="nn">configparser</span>


<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="kn">from</span> <span class="nn">tensorflow.keras</span> <span class="kn">import</span> <span class="n">backend</span> <span class="k">as</span> <span class="n">K</span>
<span class="kn">from</span> <span class="nn">tensorflow.keras.layers</span> <span class="kn">import</span> <span class="p">(</span><span class="n">Conv2D</span><span class="p">,</span> <span class="n">Input</span><span class="p">,</span> <span class="n">ZeroPadding2D</span><span class="p">,</span> <span class="n">Add</span><span class="p">,</span> <span class="n">UpSampling2D</span><span class="p">,</span> <span class="n">MaxPooling2D</span><span class="p">,</span> <span class="n">Concatenate</span><span class="p">,</span> <span class="n">Dropout</span><span class="p">,</span> <span class="n">LeakyReLU</span><span class="p">,</span> <span class="n">BatchNormalization</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">tensorflow.keras.models</span> <span class="kn">import</span> <span class="n">Model</span>
<span class="kn">from</span> <span class="nn">tensorflow.keras.regularizers</span> <span class="kn">import</span> <span class="n">l2</span>



<span class="k">def</span> <span class="nf">parser</span><span class="p">():</span>
    <span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">(</span><span class="n">description</span><span class="o">=</span><span class="s">"Darknet</span><span class="se">\'</span><span class="s">s yolov3.cfg and yolov3.weights </span><span class="se">\
</span><span class="s">                                      converted into Keras</span><span class="se">\'</span><span class="s">s yolov3.h5!"</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s">'-cfg_path'</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s">'yolov3.cfg'</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s">'-weights_path'</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s">'yolov3.weights'</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s">'-output_path'</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s">'yolov3.h5'</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s">'-weights_only'</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="s">'store_true'</span><span class="p">,</span><span class="n">help</span><span class="o">=</span><span class="s">'only save weights in yolov3.h5'</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">()</span>


<span class="k">class</span> <span class="nc">WeightLoader</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">weight_path</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fhandle</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">weight_path</span><span class="p">,</span><span class="s">'rb'</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">read_bytes</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">parser_buffer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">shape</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="s">'int32'</span><span class="p">,</span><span class="n">buffer_size</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">read_bytes</span> <span class="o">+=</span> <span class="n">buffer_size</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span>
                          <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span>
                          <span class="nb">buffer</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">fhandle</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">buffer_size</span><span class="p">)</span> <span class="p">)</span>

    <span class="k">def</span> <span class="nf">head</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

        <span class="n">major</span><span class="p">,</span> <span class="n">minor</span><span class="p">,</span> <span class="n">revision</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parser_buffer</span><span class="p">(</span>
                                   <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">3</span><span class="p">,),</span>
                                   <span class="n">dtype</span><span class="o">=</span><span class="s">'int32'</span><span class="p">,</span>
                                   <span class="n">buffer_size</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">major</span><span class="o">*</span><span class="mi">10</span><span class="o">+</span><span class="n">minor</span> <span class="o">&gt;=</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">major</span> <span class="o">&lt;</span> <span class="mi">1000</span> <span class="ow">and</span> <span class="n">minor</span> <span class="o">&lt;</span> <span class="mi">1000</span><span class="p">:</span>
            <span class="n">seen</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parser_buffer</span><span class="p">(</span>
                             <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,),</span>
                             <span class="n">dtype</span><span class="o">=</span><span class="s">'int64'</span><span class="p">,</span>
                             <span class="n">buffer_size</span><span class="o">=</span><span class="mi">8</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">seen</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parser_buffer</span><span class="p">(</span>
                             <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,),</span>
                             <span class="n">dtype</span><span class="o">=</span><span class="s">'int32'</span><span class="p">,</span>
                             <span class="n">buffer_size</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">major</span><span class="p">,</span> <span class="n">minor</span><span class="p">,</span> <span class="n">revision</span><span class="p">,</span> <span class="n">seen</span>

    <span class="k">def</span> <span class="nf">close</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fhandle</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

<span class="k">class</span> <span class="nc">DarkNetParser</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cfg_path</span><span class="p">,</span> <span class="n">weights_path</span><span class="p">):</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">block_gen</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_block</span><span class="p">(</span><span class="n">cfg_path</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">weight_loader</span> <span class="o">=</span> <span class="n">WeightLoader</span><span class="p">(</span><span class="n">weights_path</span><span class="p">)</span>
        
        <span class="n">major</span><span class="p">,</span> <span class="n">minor</span><span class="p">,</span> <span class="n">revision</span><span class="p">,</span> <span class="n">seen</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">weight_loader</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
        <span class="k">print</span><span class="p">(</span><span class="s">'weights header: '</span><span class="p">,</span><span class="n">major</span><span class="p">,</span> <span class="n">minor</span><span class="p">,</span> <span class="n">revision</span><span class="p">,</span> <span class="n">seen</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">input_layer</span> <span class="o">=</span> <span class="n">Input</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">out_index</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prev_layer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_layer</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">all_layers</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">count</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>

    
    <span class="k">def</span> <span class="nf">_get_block</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">cfg_path</span><span class="p">):</span>

        <span class="n">block</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">cfg_path</span><span class="p">,</span><span class="s">'r'</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s">'utf-8'</span><span class="p">)</span> <span class="k">as</span> <span class="n">fr</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">fr</span><span class="p">:</span>
                <span class="n">line</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
                <span class="k">if</span> <span class="s">'['</span> <span class="ow">in</span> <span class="n">line</span> <span class="ow">and</span> <span class="s">']'</span> <span class="ow">in</span> <span class="n">line</span><span class="p">:</span>        
                    <span class="k">if</span> <span class="n">block</span><span class="p">:</span>
                        <span class="k">yield</span> <span class="n">block</span>
                    <span class="n">block</span> <span class="o">=</span> <span class="p">{}</span>
                    <span class="n">block</span><span class="p">[</span><span class="s">'type'</span><span class="p">]</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s">' []'</span><span class="p">)</span>
                <span class="k">elif</span> <span class="ow">not</span> <span class="n">line</span> <span class="ow">or</span> <span class="s">'#'</span> <span class="ow">in</span> <span class="n">line</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">key</span><span class="p">,</span><span class="n">val</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s">' '</span><span class="p">,</span><span class="s">''</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">'='</span><span class="p">)</span>
                    <span class="n">key</span><span class="p">,</span><span class="n">val</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="n">strip</span><span class="p">(),</span> <span class="n">val</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
                    <span class="n">block</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>

            <span class="k">yield</span> <span class="n">block</span>


    <span class="k">def</span> <span class="nf">conv</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">block</span><span class="p">):</span>
        <span class="s">'''When reading darknet's yolov3.weights file, the order is
          1 - biasÔºõ
          2 - If there is a bn, read scaleÔºåmeanÔºåvar 
          3 - Get the weights
        '''</span>
        <span class="c1"># Darknet serializes convolutional weights as:
</span>
        <span class="c1"># [bias/beta, [gamma, mean, variance], conv_weights]
</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">count</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="c1"># read conv block
</span>
        <span class="n">filters</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">block</span><span class="p">[</span><span class="s">'filters'</span><span class="p">])</span>
        <span class="n">size</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">block</span><span class="p">[</span><span class="s">'size'</span><span class="p">])</span>
        <span class="n">stride</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">block</span><span class="p">[</span><span class="s">'stride'</span><span class="p">])</span>
        <span class="n">pad</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">block</span><span class="p">[</span><span class="s">'pad'</span><span class="p">])</span>
        <span class="n">activation</span> <span class="o">=</span> <span class="n">block</span><span class="p">[</span><span class="s">'activation'</span><span class="p">]</span>
        <span class="n">groups</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">block</span><span class="p">[</span><span class="s">'groups'</span><span class="p">])</span> <span class="k">if</span> <span class="s">'groups'</span> <span class="ow">in</span> <span class="n">block</span> <span class="k">else</span> <span class="mi">1</span>
        
        <span class="n">padding</span> <span class="o">=</span> <span class="s">'same'</span> <span class="k">if</span> <span class="n">pad</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">stride</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="s">'valid'</span>
        <span class="n">batch_normalize</span> <span class="o">=</span> <span class="s">'batch_normalize'</span> <span class="ow">in</span> <span class="n">block</span>
        
        <span class="n">prev_layer_shape</span> <span class="o">=</span> <span class="n">K</span><span class="o">.</span><span class="n">int_shape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">prev_layer</span><span class="p">)</span>
        <span class="n">weights_shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">prev_layer_shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="n">groups</span><span class="p">),</span> <span class="n">filters</span><span class="p">)</span>
        <span class="n">darknet_w_shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">filters</span><span class="p">,</span> <span class="n">weights_shape</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">size</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>
        <span class="n">weights_size</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">weights_shape</span><span class="p">)</span>

        <span class="k">print</span><span class="p">(</span><span class="s">'+'</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">count</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="s">'conv2d'</span><span class="p">,</span> 
              <span class="s">'bn'</span> <span class="k">if</span> <span class="n">batch_normalize</span> <span class="k">else</span> <span class="s">' '</span><span class="p">,</span>
              <span class="n">activation</span><span class="p">,</span>
              <span class="n">weights_shape</span><span class="p">)</span>

        <span class="c1"># Read the bias
</span>
        <span class="n">conv_bias</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">weight_loader</span><span class="o">.</span><span class="n">parser_buffer</span><span class="p">(</span>
                                 <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">filters</span><span class="p">,),</span>
                                 <span class="n">dtype</span><span class="o">=</span><span class="s">'float32'</span><span class="p">,</span>
                                 <span class="n">buffer_size</span><span class="o">=</span><span class="n">filters</span><span class="o">*</span><span class="mi">4</span><span class="p">)</span>
 
        <span class="c1"># If there is a bn, read scaleÔºåmeanÔºåvar 
</span>
        <span class="k">if</span> <span class="n">batch_normalize</span><span class="p">:</span>
            <span class="n">bn_weight_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bn</span><span class="p">(</span><span class="n">filters</span><span class="p">,</span> <span class="n">conv_bias</span><span class="p">)</span>

        <span class="c1"># Read the weights
</span>
        <span class="n">conv_weights</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">weight_loader</span><span class="o">.</span><span class="n">parser_buffer</span><span class="p">(</span>
                              <span class="n">shape</span><span class="o">=</span><span class="n">darknet_w_shape</span><span class="p">,</span>
                              <span class="n">dtype</span><span class="o">=</span><span class="s">'float32'</span><span class="p">,</span>
                              <span class="n">buffer_size</span><span class="o">=</span><span class="n">weights_size</span><span class="o">*</span><span class="mi">4</span><span class="p">)</span>

        <span class="c1"># DarkNet conv_weights are serialized Caffe-style:
</span>
        <span class="c1"># (out_dim, in_dim, height, width)
</span>
        <span class="c1"># We would like to set these to Tensorflow order:
</span>
        <span class="c1"># (height, width, in_dim, out_dim)
</span>
        <span class="n">conv_weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">conv_weights</span><span class="p">,</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
        <span class="n">conv_weights</span> <span class="o">=</span> <span class="p">[</span><span class="n">conv_weights</span><span class="p">]</span> <span class="k">if</span> <span class="n">batch_normalize</span> <span class="k">else</span> \
                              <span class="p">[</span><span class="n">conv_weights</span><span class="p">,</span> <span class="n">conv_bias</span><span class="p">]</span>

        <span class="n">act_fn</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">if</span> <span class="n">activation</span> <span class="o">==</span> <span class="s">'leaky'</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">elif</span> <span class="n">activation</span> <span class="o">!=</span> <span class="s">'linear'</span><span class="p">:</span>
            <span class="k">raise</span>

        <span class="k">if</span> <span class="n">stride</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">prev_layer</span> <span class="o">=</span> <span class="n">ZeroPadding2D</span><span class="p">(((</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">)))(</span><span class="bp">self</span><span class="o">.</span><span class="n">prev_layer</span><span class="p">)</span>

        <span class="n">conv_layer</span> <span class="o">=</span> <span class="p">(</span><span class="n">Conv2D</span><span class="p">(</span>
                <span class="n">filters</span><span class="p">,</span> <span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">size</span><span class="p">),</span>
                <span class="n">strides</span><span class="o">=</span><span class="p">(</span><span class="n">stride</span><span class="p">,</span> <span class="n">stride</span><span class="p">),</span>
                <span class="n">kernel_regularizer</span><span class="o">=</span><span class="n">l2</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">weight_decay</span><span class="p">),</span>
                <span class="n">use_bias</span><span class="o">=</span><span class="ow">not</span> <span class="n">batch_normalize</span><span class="p">,</span>
                <span class="n">weights</span><span class="o">=</span><span class="n">conv_weights</span><span class="p">,</span>
                <span class="n">activation</span><span class="o">=</span><span class="n">act_fn</span><span class="p">,</span>
                <span class="n">groups</span><span class="o">=</span><span class="n">groups</span><span class="p">,</span>
                <span class="n">padding</span><span class="o">=</span><span class="n">padding</span><span class="p">))(</span><span class="bp">self</span><span class="o">.</span><span class="n">prev_layer</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">batch_normalize</span><span class="p">:</span>
             <span class="n">conv_layer</span> <span class="o">=</span> <span class="n">BatchNormalization</span><span class="p">(</span><span class="n">weights</span><span class="o">=</span><span class="n">bn_weight_list</span><span class="p">)(</span><span class="n">conv_layer</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prev_layer</span> <span class="o">=</span> <span class="n">conv_layer</span>

        <span class="k">if</span> <span class="n">activation</span> <span class="o">==</span> <span class="s">'linear'</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">all_layers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">prev_layer</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">activation</span> <span class="o">==</span> <span class="s">'leaky'</span><span class="p">:</span>
            <span class="n">act_layer</span> <span class="o">=</span> <span class="n">LeakyReLU</span><span class="p">(</span><span class="n">alpha</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)(</span><span class="bp">self</span><span class="o">.</span><span class="n">prev_layer</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">prev_layer</span> <span class="o">=</span> <span class="n">act_layer</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">all_layers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">act_layer</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">bn</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">filters</span><span class="p">,</span><span class="n">conv_bias</span><span class="p">):</span>
        <span class="s">'''bn has 4 parameters. they're bias, scale, mean, var,
           The bias has been read, and the remaining three are read here, scale, mean, var '''</span>
           
        <span class="n">bn_weights</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">weight_loader</span><span class="o">.</span><span class="n">parser_buffer</span><span class="p">(</span>
                              <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="n">filters</span><span class="p">),</span>
                              <span class="n">dtype</span><span class="o">=</span><span class="s">'float32'</span><span class="p">,</span>
                              <span class="n">buffer_size</span><span class="o">=</span><span class="p">(</span><span class="n">filters</span><span class="o">*</span><span class="mi">3</span><span class="p">)</span><span class="o">*</span><span class="mi">4</span><span class="p">)</span>
        <span class="c1"># scale, bias, mean,var
</span>        <span class="n">bn_weight_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">bn_weights</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                          <span class="n">conv_bias</span><span class="p">,</span>
                          <span class="n">bn_weights</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                          <span class="n">bn_weights</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="p">]</span>
        <span class="k">return</span> <span class="n">bn_weight_list</span>
       
    <span class="k">def</span> <span class="nf">maxpool</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">block</span><span class="p">):</span>
        <span class="n">size</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">block</span><span class="p">[</span><span class="s">'size'</span><span class="p">])</span>
        <span class="n">stride</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">block</span><span class="p">[</span><span class="s">'stride'</span><span class="p">])</span>
        <span class="n">maxpool_layer</span> <span class="o">=</span> <span class="n">MaxPooling2D</span><span class="p">(</span><span class="n">pool_size</span><span class="o">=</span><span class="p">(</span><span class="n">size</span><span class="p">,</span><span class="n">size</span><span class="p">),</span>
                        <span class="n">strides</span><span class="o">=</span><span class="p">(</span><span class="n">stride</span><span class="p">,</span><span class="n">stride</span><span class="p">),</span>
                        <span class="n">padding</span><span class="o">=</span><span class="s">'same'</span><span class="p">)(</span><span class="bp">self</span><span class="o">.</span><span class="n">prev_layer</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">all_layers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">maxpool_layer</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prev_layer</span> <span class="o">=</span> <span class="n">maxpool_layer</span>

    <span class="k">def</span> <span class="nf">shortcut</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">block</span><span class="p">):</span>
        <span class="n">index</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">block</span><span class="p">[</span><span class="s">'from'</span><span class="p">])</span>
        <span class="n">activation</span> <span class="o">=</span> <span class="n">block</span><span class="p">[</span><span class="s">'activation'</span><span class="p">]</span>
        <span class="k">assert</span> <span class="n">activation</span> <span class="o">==</span> <span class="s">'linear'</span><span class="p">,</span> <span class="s">'Only linear activation supported.'</span>
        <span class="n">shortcut_layer</span> <span class="o">=</span> <span class="n">Add</span><span class="p">()([</span><span class="bp">self</span><span class="o">.</span><span class="n">all_layers</span><span class="p">[</span><span class="n">index</span><span class="p">],</span><span class="bp">self</span><span class="o">.</span><span class="n">prev_layer</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">all_layers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">shortcut_layer</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prev_layer</span> <span class="o">=</span> <span class="n">shortcut_layer</span>

    <span class="k">def</span> <span class="nf">route</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">block</span><span class="p">):</span>
        <span class="n">layers_ids</span> <span class="o">=</span> <span class="n">block</span><span class="p">[</span><span class="s">'layers'</span><span class="p">]</span>
        <span class="n">ids</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">layers_ids</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">','</span><span class="p">)]</span>
        <span class="n">layers</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">all_layers</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">ids</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">layers</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="s">'Concatenating route layers:'</span><span class="p">,</span> <span class="n">layers</span><span class="p">)</span>
            <span class="n">concatenate_layer</span> <span class="o">=</span> <span class="n">Concatenate</span><span class="p">()(</span><span class="n">layers</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">all_layers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">concatenate_layer</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">prev_layer</span> <span class="o">=</span> <span class="n">concatenate_layer</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">skip_layer</span> <span class="o">=</span> <span class="n">layers</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">all_layers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">skip_layer</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">prev_layer</span> <span class="o">=</span> <span class="n">skip_layer</span>

    <span class="k">def</span> <span class="nf">upsample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">block</span><span class="p">):</span>
        <span class="n">stride</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">block</span><span class="p">[</span><span class="s">'stride'</span><span class="p">])</span>
        <span class="k">assert</span> <span class="n">stride</span> <span class="o">==</span> <span class="mi">2</span><span class="p">,</span> <span class="s">'Only stride=2 supported.'</span>
        <span class="n">upsample_layer</span> <span class="o">=</span> <span class="n">UpSampling2D</span><span class="p">(</span><span class="n">stride</span><span class="p">)(</span><span class="bp">self</span><span class="o">.</span><span class="n">prev_layer</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">all_layers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">upsample_layer</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prev_layer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_layers</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    
    <span class="k">def</span> <span class="nf">yolo</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">block</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">out_index</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">all_layers</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">all_layers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prev_layer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_layers</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">dropout</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">block</span><span class="p">):</span>
        <span class="n">prob</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">block</span><span class="p">[</span><span class="s">'probability'</span><span class="p">])</span>
        <span class="n">dropout_layer</span> <span class="o">=</span> <span class="n">Dropout</span><span class="p">(</span><span class="n">prob</span><span class="p">)(</span><span class="bp">self</span><span class="o">.</span><span class="n">prev_layer</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">all_layers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dropout_layer</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prev_layer</span> <span class="o">=</span> <span class="n">dropout_layer</span>

    <span class="k">def</span> <span class="nf">net</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">block</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">weight_decay</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">block</span><span class="p">[</span><span class="s">'decay'</span><span class="p">])</span>


    <span class="k">def</span> <span class="nf">create_and_save</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">weights_only</span><span class="p">,</span><span class="n">output_path</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">out_index</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">out_index</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">all_layers</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span> <span class="p">)</span>

        <span class="n">output_layers</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">all_layers</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">out_index</span><span class="p">]</span>
        <span class="n">model</span> <span class="o">=</span> <span class="n">Model</span><span class="p">(</span><span class="n">inputs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">input_layer</span><span class="p">,</span>
                      <span class="n">outputs</span><span class="o">=</span><span class="n">output_layers</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">summary</span><span class="p">())</span>

        <span class="k">if</span> <span class="n">weights_only</span><span class="p">:</span>
            <span class="n">model</span><span class="o">.</span><span class="n">save_weights</span><span class="p">(</span><span class="n">output_path</span><span class="p">)</span>
            <span class="k">print</span><span class="p">(</span><span class="s">'Saved Keras weights to {}'</span><span class="o">.</span><span class="nb">format</span><span class="p">(</span><span class="n">output_path</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">model</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">output_path</span><span class="p">)</span>
            <span class="k">print</span><span class="p">(</span><span class="s">'Saved Keras model to {}'</span><span class="o">.</span><span class="nb">format</span><span class="p">(</span><span class="n">output_path</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">close</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">weight_loader</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        

<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>

    <span class="n">args</span> <span class="o">=</span> <span class="n">parser</span><span class="p">()</span>
    <span class="k">print</span><span class="p">(</span><span class="s">'loading weights...'</span><span class="p">)</span>

    <span class="n">cfg_parser</span> <span class="o">=</span> <span class="n">DarkNetParser</span><span class="p">(</span><span class="n">args</span><span class="o">.</span><span class="n">cfg_path</span><span class="p">,</span><span class="n">args</span><span class="o">.</span><span class="n">weights_path</span><span class="p">)</span>

    <span class="k">print</span><span class="p">(</span><span class="s">'creating keras model...'</span><span class="p">)</span>

    <span class="n">layers_fun</span> <span class="o">=</span> <span class="p">{</span><span class="s">'convolutional'</span><span class="p">:</span><span class="n">cfg_parser</span><span class="o">.</span><span class="n">conv</span><span class="p">,</span>
                 <span class="s">'net'</span><span class="p">:</span><span class="n">cfg_parser</span><span class="o">.</span><span class="n">net</span><span class="p">,</span>
                 <span class="s">'yolo'</span><span class="p">:</span><span class="n">cfg_parser</span><span class="o">.</span><span class="n">yolo</span><span class="p">,</span>
                 <span class="s">'route'</span><span class="p">:</span><span class="n">cfg_parser</span><span class="o">.</span><span class="n">route</span><span class="p">,</span>
                 <span class="s">'upsample'</span><span class="p">:</span><span class="n">cfg_parser</span><span class="o">.</span><span class="n">upsample</span><span class="p">,</span>
                 <span class="s">'maxpool'</span><span class="p">:</span><span class="n">cfg_parser</span><span class="o">.</span><span class="n">maxpool</span><span class="p">,</span>
                 <span class="s">'shortcut'</span><span class="p">:</span><span class="n">cfg_parser</span><span class="o">.</span><span class="n">shortcut</span><span class="p">,</span>
                 <span class="s">'dropout'</span><span class="p">:</span><span class="n">cfg_parser</span><span class="o">.</span><span class="n">dropout</span>
                 <span class="p">}</span>

    <span class="k">print</span><span class="p">(</span><span class="s">'Parsing Darknet config.'</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">index</span><span class="p">,</span><span class="n">block</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">cfg_parser</span><span class="o">.</span><span class="n">block_gen</span><span class="p">):</span>
        <span class="nb">type</span> <span class="o">=</span> <span class="n">block</span><span class="p">[</span><span class="s">'type'</span><span class="p">]</span>
        <span class="n">layers_fun</span><span class="p">[</span><span class="nb">type</span><span class="p">](</span><span class="n">block</span><span class="p">)</span>

    <span class="n">cfg_parser</span><span class="o">.</span><span class="n">create_and_save</span><span class="p">(</span><span class="n">args</span><span class="o">.</span><span class="n">weights_only</span><span class="p">,</span> <span class="n">args</span><span class="o">.</span><span class="n">output_path</span><span class="p">)</span>
    <span class="n">cfg_parser</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">'__main__'</span><span class="p">:</span>
    <span class="n">main</span><span class="p">()</span>

</code></pre></div></div>

<p>Please save the code and rename it to <code class="highlighter-rouge">convert.py</code>. Usage is the same as in keras-yolo3:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>python convert.py <span class="nt">-w</span> yolov3.cfg yolov3.weights model_data/yolov3.h5
</code></pre></div></div>

<p>This time, no buffer issue.</p>

<hr />
<p><em>Note: Thanks to the articles ‚Äú<a href="https://www.cnblogs.com/shouhuxianjian/p/10567201.html">Ê®°ÂûãËΩ¨Êç¢[yolov3Ê®°ÂûãÂú®keras‰∏édarknet‰πãÈó¥ËΩ¨Êç¢]</a>‚Äù for the help.</em></p>
:ET